#lang eopl



;; Ejercicios - IL 1.1.1

;Punto 1

;; invert : parámetros: recibe como entrada una lista l que está compuesta por listas de dos elementos (x, y).
;; Proposito:La función debe retornar una lista similar a l, con pares ordenados invertidos, es decir, y, x.
;; 
;; <lista> := ()
;; <sublista> := (<valor-de-scheme> <valor-de-scheme>)
;; <lista> := (<sublista> <lista>)

( define invert
   (lambda (l)
     (if (null? l)
         '()
     (cons (cons (cadar l) (cons (caar l) empty)) (invert (cdr l)) ))
   )
 )

;;Pruebas

(invert '(("estás" "cómo?")(a 1) (a 2) (1 b) (2 b)))
(invert '((50 93) (1 41) (82 7) (a e) ("hola" "Mundo")))
(invert '(("que" "creo") ("es" "racket") ("genial" "muy") (17 29) (81 o)))


;Punto 2
;; down:
;; Proposito:
;; L ->  L: Procedimiento que recibe una lista en cuyo interior hay n elementos y
;; a cada elemento le agrega un nivel mas (lo introduce en una lista).
;; <Lista> := ()
;;         := (<valor-de-scheme> <lista>)

(define down (lambda(l)
        (if (eqv? l empty ) empty
        (cons (cons(car l) empty) (down (cdr l))))
        ))

;; Pruebas:

(down '(1 2 3)) ; ---> '((1) (2) (3))
(down '((una) (buena) (idea))) ; ---> '(((una)) ((buena)) ((idea)))
(down '(un (objeto (mas)) complicado)) ;---> '((un) ((objeto (mas))) (complicado))

;Punto 5

;; list-index-aux :
;; Propósito:
;; int x int x L -> int' : Este procedimiento retorna la posición del primer elemento de la lista que cumpla con el predicado 'pred',
;; iniciando desde la posición 'n'.
;; <lista> ::= ()
;;         ::= (<int><lista>)

(define list-index-aux
  (lambda (n pred lst)
    (if (null? lst) 
        #f
        (if (pred (car lst))
            n
            (list-index-aux (+ n 1) pred (cdr lst))
            )
        )
    )  
  )

;; list-index :
;; Propósito:
;; int x L -> int' : Funciona haciendo un llamado a la función <list-index-aux>, estableciendo un valor inicial en el valor
;; 'n' de dicha función.
;; <lista> ::= ()
;;         ::= (<int><lista>)

(define list-index
  (lambda (pred lst)
    (list-index-aux 0 pred lst)
    )
  )

;; Pruebas
(list-index number? '(a 2 (1 3) b 7))
(list-index symbol? '(a (b c) 17 foo))
(list-index symbol? '(1 2 (a b) 3))

;punto 6
;; swapper :recibe 3 argumentos: un elemento E1, otro elemento E2, y una lista L.
;; Proposito: La función retorna una lista similar a L, sólo que cada ocurrencia anterior de E1 será reemplazada por E2
;; y cada ocurrencia anterior de E2 será reemplazada por E1
;; S, S, L -> L
;;
;; <lista> := ()
;;  := (<valor-de-scheme> <lista>)

(define swapper
  (lambda (e1 e2 l)

      (if (eqv? l empty) '()
          (if(eqv? (car l) e1)
             (cons e2 (swapper e1 e2 (cdr l)))
             (if (eqv? (car l) e2)
                 (cons e1 (swapper e1 e2 (cdr l)))
                 (cons (car l) (swapper e1 e2 (cdr l)))
                 )
             )
          )
      
    )
  )

;;Pruebas
(swapper 'c 'a '(d b c a))
(swapper 'w 'v '(d v c w n m c w o p v))
(swapper 'x 'l '(l b c x c l q x x n l))
(swapper 'd 'b '(d b c a a b b b d d d d d))


; Punto 7
;; cartesian-product:
;; Proposito:
;; L , L -> L: Procedimiento que recibe dos listas y realiza el producto cartesiano
;; entre aquellas dos listas recibidas. Este producto es retornado en forma de
;; lista que contiene todas las duplas.
;; <Lista> := ()
;;         := (<valor-de-scheme> <lista>)

(define cartesian-product
  (lambda(l1 l2)
  (letrec
      (
       (pivotfunction
        (lambda (l1)
          (if (eqv? l1 empty) empty
              (append (cartesianfunction (car l1) l2) (pivotfunction (cdr l1)))
        )))
       (cartesianfunction
        (lambda (pivot l)
          (if (eqv? l empty) empty
              (cons (cons pivot (cons (car l) empty)) (cartesianfunction pivot (cdr l)))
       )))
       )
    (pivotfunction l1)
      )
    )
  )

;; Pruebas
(cartesian-product '(a b c) '(x y)) ; ---> '((a x) (a y) (b x) (b y) (c x) (c y))
(cartesian-product '(p q r) '(5 6 7))
; --> '((p 5) (p 6) (p 7) (q 5) (q 6) (q 7) (r 5) (r 6) (r 7))

;Punto 10

;; up-head :
;; Propósito:
;; L x L -> L' : Recibe una lista sin su cabeza como primer argumento, y la cabeza de la lista como segundo.
;; Devuelve una lista con el segundo argumento en primera posición.
;; <lista> ::= ()
;;         ::= (<valor-de-scheme><lista>)
(define up-head
  (lambda (tail head)
    (if (null? head)
        tail
        (cons (car head) (up-head tail (cdr head))))))

;; up-aux :
;; Propósito:
;; L x L -> L' : Devuelve la lista reemplazando la cabeza de la lista por el segundo parámetro ingresado.
;; <lista> ::= ()
;;         ::= (<valor-de-scheme><lista>)
(define up-aux
  (lambda (tail element)
    (if (list? element)
        (up-head tail element)
        (cons element tail))))

;; up :
;; Propósito:
;; L -> L' : remueve el par de paréntesis a cada elemento de nivel más alto. Si no poseen paréntesis,
;; se retorna la lista tal como fue recibida.
;; <lista> ::= '()
;;         ::= (<valor-de-scheme><lista>)
(define up
  (lambda (lst)
    (if (null? lst)
        '()
        (up-aux (up (cdr lst)) (car lst)))))

;; Pruebas
(up '((1 2) (3 4)))
(up '((x (y)) z))

;Punto 11

;; zip : recibe como entrada tres parámetros: una función binaria F, y dos listas L1 y L2, ambas de igual tamaño.
;; Proposito: retornar una lista donde la posición n-ésima es el resultado de aplicar F sobre los elementos de L1 yL2 en esa
;; posición.
;; F, L1, L2 -> L
;; <lista> := ()
;;  := (<int> <lista>)

(define zip
  (lambda (f l1 l2)

      (if (and (eqv? l1 empty)(eqv? l2 empty))
          '()
          (cons (f (car l1) (car l2)) (zip f (cdr l1) (cdr l2)))
          
          )
      
    )
  )

;;Pruebas
(zip + '(1 4 7 9) '(6 2 6 0))
(zip * '(11 5 6) '(10 9 8))
(zip - '(20 45 65 6) '(10 40 18 5))


;; Punto 12
;; filter-acum:
;; Proposito:
;; a, b, F, acum, filter -> int: Recibe 5 entradas, las dos primeras corresponden a los valores
;; que  determinan el inicio y el final del intervalo [a, b]. La entrada F
;; corresponde a aquella funcion que se va a aplicar a todos los elementos pertenecientes
;; al intervalo [a, b] que cumplan la condicion que establece la funcion filter.
;;   <lista-enteros> := ()
;;                   := (<int> <lista>)
;Punto 12

(define filter-acum
  (lambda(a b F acum filter)
    (letrec
        (
         (list-filter
          (lambda (a b filter)
            (if (> a b) empty
                (if (filter a) (cons a (list-filter (+ a 1) b filter)) (list-filter (+ a 1) b filter))  
          )))
         (op-applier
          (lambda (F acum l)
            (if (eqv? l  empty) acum
                (op-applier F (F acum (car l)) (cdr l))
             )
            )
         ))
      (op-applier F acum (list-filter a b filter))
        )
    )
  )
  
;Punto 15

;; count-even :
;; Propósito:
;; bintree -> int' : Recorre un árbol y hace el conteo de la cantidad de números pares presentes.
;; En caso de que la lista sea vacía, retorna 0.
;; <bintree> ::= ()
;;           ::= (<int><bintree><bintree>)
(define count-even
  (lambda (arbol)
    (if(null? arbol)
       0
       (if(even? (car arbol))
            (+ 1(+  (count-even (cadr arbol))
                (count-even (caddr arbol))
                ))
            (+  (count-even (cadr arbol))
                (count-even (caddr arbol))
                )
            )
       )
    )
  )

;; count-odd :
;; Propósito:
;; bintree -> int' : Recorre un árbol y hace el conteo de la cantidad de números impares presentes.
;; En caso de que la lista sea vacía, retorna 0.
;; <bintree> ::= ()
;;           ::= (<int><bintree><bintree>)
(define count-odd
  (lambda (arbol)
    (if(null? arbol)
       0
           (if (odd? (car arbol))
            (+ 1(+  (count-odd (cadr arbol))
                (count-odd (caddr arbol))
                ))
            (+  (count-odd (cadr arbol))
                (count-odd (caddr arbol))
                )
            )
       )

    )
  )

;; count-odd-and-even :
;; Propósito:
;; Int x Int -> L' : retorna una lista con dos elementos correspondientes
;; a la cantidad de pares e impares en arbol.
;; <lista> ::= ()
;;         ::= (<Listof(Int)>)
(define count-odd-and-even
  (lambda (arbol)
    (cons (count-even arbol) (cons (count-odd arbol) empty))
    )
  )

;;Pruebas
(count-odd-and-even '(14 (7 () (12 () ()))
                      (26 (20 (17 () ())
                              ())
                          (31 () ()))))
(count-odd-and-even '(2 (4 () (19 () ()))
                      (1 (3 (7 () ())
                            ())
                        (15 () ()))))

;Punto 16

;; simpson-rule:recibe como entrada cuatro parámetros: una función F, y dos valores donde para la integral a y b, y algún
;; entero par.
;; Proposito: cálcula la integral de una función f entre los valores a y b mediante la regla de Simpson.
;; F, int, int, int%2=0 -> int
;;

(define simpson-rule
  (lambda (f a b n)
    (letrec (
              (h (/ (- b a) n))         
              (one-point (lambda (yx) (f (+ a (* h yx)))))

              (term-x (lambda (x) (* (cond ((or (= x 0) (= x n)) 1)
                          ((odd? x) 4)
                          (else 2)) (one-point x))))
            

              (counter (lambda (c) (+ c 1)))
              
              (sum-values (lambda (f a g b)
                (if (> a b)
                    0
                    (+ (f a)
                       (sum-values f (g a) g b)))))
             
             )
      (* (/ h 3) (sum-values term-x 0 counter n))
      )
    )
  )


; Punto 17
;; prod-escalar-matrix:
;; Proposito:
;; mat'(L1, L2.. Ln), vec(L) -> L: Recibe dos entradas, la primera
;; entrada corresponde a una matriz la cual es representada por medio de
;; una lista de listas.
;; La segunda entrada consiste en un vector el cual es representado por medio de
;; una lista.
;; El procedimiento se encarga de realizar la multiplicacion de una matriz por un vector
;; y retornar el resultado en forma de lista.
;; <Vector> := ()
;;         := (<entero> <vector>)
;; <Matriz>:= '()
;;         := (<vector> <Matriz>)
;; 

(define prod-scalar-matrix
  (lambda (mat vec)
    (letrec
        (
         (row-iterator
          (lambda(mat vec)
            (if (eqv? mat empty) empty
                (cons (multiplier (car mat) vec) (row-iterator (cdr mat) vec))
                )
            ))
         (multiplier
          (lambda (l1 vec)
            (if (eqv? l1 empty) empty
            (cons (* (car l1 ) (car vec)) (multiplier (cdr l1) (cdr vec)))
            )
            ))
         )
      (row-iterator mat vec)
    )))

;; Pruebas:
(prod-scalar-matrix '((1 1) (2 2)) '(2 3)) ; --> '((2 3) (4 6))
(prod-scalar-matrix '((1 1) (2 2) (3 3)) '(2 3)) ; --> '((2 3) (4 6) (6 9))


;Punto 18

;; Pascal:
;; Proposito: retorna la fila N del triangulo de Pascal.
;; int -> L
;;
;;

(define pascal (lambda (n)
                 (letrec (
                           (init-l (cons 1 empty))
                          
                           (next-list (lambda (lst)
                                        ( if (null? (cdr lst)) (cons 1 empty)
                                             (cons(+ (car lst) (cadr lst))
                                                  (next-list (cdr lst))))))

                           (pascal-row (lambda(init-lst n)
                                          (if (or (= 0 n) (= n 1))
                                              init-lst
                                              (pascal-row (append
                                                            (cons 1 empty)
                                                            (next-list init-lst)) (- n 1)))))
                          )
                   (pascal-row init-l n)
                   )
                 )
  )


#lang eopl



;; Ejercicios - IL 1.1.1

;Punto 1

;; invert :recibe como entrada tres parámetros: una función binaria F, y dos listas L1 y L2, ambas de igual tamaño.
;; Proposito: retornar una lista donde la posición n-ésima es el resultado de aplicar F sobre los elementos de L1 yL2 en esa
;; posición.
;; 
;;
;;<lista> := ()
;;  := (<valor-de-scheme> <lista>)

( define invert
   (lambda (l)
     (if (null? l)
         '()
     (cons (cons (cadar l) (cons (caar l) empty)) (invert (cdr l)) ))
   )
 )

;;Pruebas

(invert '(("estás" "cómo?")(a 1) (a 2) (1 b) (2 b)))
(invert '((50 93) (1 41) (82 7) (a e) ("hola" "Mundo")))
(invert '(("que" "creo") ("es" "racket") ("genial" "muy") (17 29) (81 o)))


;Punto 2
(define down (lambda(l)
        (if (eqv? l empty ) empty
        (cons (cons(car l) empty) (down (cdr l))))
        ))

;punto 6

;; swapper :recibe como entrada tres parámetros: una función binaria F, y dos listas L1 y L2, ambas de igual tamaño.
;; Proposito: retornar una lista donde la posición n-ésima es el resultado de aplicar F sobre los elementos de L1 yL2 en esa
;; posición.
;; 
;;
;;<lista> := ()
;;  := (<valor-de-scheme> <lista>)

(define swapper
  (lambda (e1 e2 l)

      (if (eqv? l empty) '()
          (if(eqv? (car l) e1)
             (cons e2 (swapper e1 e2 (cdr l)))
             (if (eqv? (car l) e2)
                 (cons e1 (swapper e1 e2 (cdr l)))
                 (cons (car l) (swapper e1 e2 (cdr l)))
                 )
             )
          )
      
    )
  )

;;Pruebas
(swapper 'c 'a '(d b c a))
(swapper 'w 'v '(d v c w n m c w o p v))
(swapper 'x 'l '(l b c x c l q x x n l))
(swapper 'd 'b '(d b c a a b b b d d d d d))

;Punto 7

(define cartesian-product
  (letrec
  ) 


;Punto 11

;; zip :recibe como entrada tres parámetros: una función binaria F, y dos listas L1 y L2, ambas de igual tamaño.
;; Proposito: retornar una lista donde la posición n-ésima es el resultado de aplicar F sobre los elementos de L1 yL2 en esa
;; posición.
;; 
;;
;;<lista> := ()
;;  := (<valor-de-scheme> <lista>)

(define zip
  (lambda (f l1 l2)

      (if (and (eqv? l1 empty)(eqv? l2 empty))
          '()
          (cons (f (car l1) (car l2)) (zip f (cdr l1) (cdr l2)))
          
          )
      
    )
  )

;;Pruebas
(zip + '(1 4 7 9) '(6 2 6 0))
(zip * '(11 5 6) '(10 9 8))
(zip - '(20 45 65 6) '(10 40 18 5))


;Punto 12


;Punto 17



;Punto 22 
